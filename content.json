{"posts":[{"title":"EthernetLab","text":"以太网组网实验实验时间：2023.10.20实验目的​ 物理网络是由多个节点连接起来的网络,是构成互联网的重要部分,可以互相传输数据。本实验使用以太网交换机来建立一个独立的物理网络，它使用双绞线作为传输介质。这个实验旨在观察和测试网络节点之间的通信情况。具体目的如下: 了解局域网的组成和功能。 掌握以太网的配置和连接方法。 学习以太网的地址格式和规则。 实验原理 以太网：以太网是一种常见的有线局域网技术，它广泛应用于家庭和企业的网络建设。无线网络也需要通过以太网来接入互联网。以太网主要包括以太网设备、以太网卡和双绞线三个部分。 连接方式：要想加入以太网，主机必须有一块以太网卡，现在的计算机通常都内置了以太网卡。集线器和交换机是两种常用的以太网设备，它们都有多个以太网口，可以用双绞线把主机的网卡和设备的口连接起来，形成一个独立的物理网络，网络中的节点可以互相通信。 ​ 双绞线以太网组网如下图所示: 实验环境实验地点：​ 济事楼330机房 实验设备：​ PC两台,交换机一台,双绞线两根 ​ 实验拓扑结构如下: ​ 计算机Host1作为操作平台,Host2作为测试平台. 实验内容 建立以太网局域网 用双绞线把两台计算机的网卡和交换机的端口连起来，形成一个局域网。 给每台计算机的网卡分配一个IP地址，使用TCP/IP协议进行通信。把子网掩码都设为255.255.255.0，把Host1的IP地址设为192.168.1.12，把Host2的IP地址设为192.168.1.10。 用ping命令来检查两台计算机是否能互相通信，如果能收到回应，就说明连通成功。 查看以太网网卡地址：用ipconfig命令来查看每台计算机的网卡物理地址，它是一个唯一的标识符，由六个十六进制数组成。 实验步骤 用两根双绞线分别将两台计算机网卡同交换机端口连接起来,以形成局域网. 注意检查交换机端口的指示灯是否亮起且为绿色,实验时我和同学因为交换机一直显示无法连接到主机 为两台主机配置IP地址。将HostlP地址设为192.168.1.12，子网掩码为255.255.255.0 ;Host2IP地址设为192.168.1.10，子网掩码为255.255.255.0 在windows操作系统中,具体步骤为: 在设置中选择网络,选择更改适配器设置;右击‘以太网’,选择属性,选择‘Internet协议版本4(TCP/IPv4),点击属性 设置IP地址、子网掩码、默认网关,点击确认保存. 测试Host1和Host2是否连通。打开Hostl命令行窗口，输入ping Host2IP地址指令,可以看到来自Host2的回复. 查看Host1的以太网物理地址.在命令行窗口中输入命令:ipconfig /all,能在输出中看到Host1的以太网IP地址和物理地址. 实验结论 在建立以太网局域网时，正确连接双绞线至计算机的网卡和交换机的端口是至关重要的，一定要检查,确保交换机端口指示灯显示正常，以维持网络正常运行. 配置IP地址和子网掩码是局域网通信的基本要求.确保每台计算机拥有唯一的IP地址，并且它们的子网掩码相同. 使用ping命令可以方便地测试两台计算机是否可以相互通信，也可以使用arp命令查看通信情况. 物理网络中的每个网络接口都有一个唯一的物理地址，通常由六个十六进制数表示。","link":"/2023/10/25/EthernetLab/"},{"title":"TCPLab","text":"TCP协议与并发服务编程实验实验时间：2023.10.8实验目的本实验旨在利用Socket编写一个基于TCP协议的程序，实现即时通信，并且能够并发访问。具体目标如下： 掌握利用Socket编写基于TCP协议的程序的方法，基本架构等。 学习面向连接通信方式，并与无连接通信方式进行对比学习。 理解并发服务的实现原理及过程。 实验原理TCP服务器采用并发服务能力，允许同时处理多个客户端的请求。这使得服务器可以同时与多个客户端建立会话，提高了服务器的性能和效率。 并发服务器程序通常由两部分组成。 主进程： 负责请求调度，接收客户端请求，并为每个请求创建一个服务处理线程。 服务处理线程： 负责具体的会话处理，为客户请求提供服务。服务处理线程可以被主进程不断创建。 并发处理的数量理论上没有限制，主要取决于计算机的处理能力，包括CPU核数量和内存大小。如果同时有N个客户访问服务器，就有N＋1个线程在运行。 TCP通信流程图如下： 在流程图中，TCPClient类实现了客户机，MainServer类实现了服务器主进程，ServiceServer实现了服务线程，承担实际服务处理。客户机通过端口号5588访问服务器，而客户机端口由系统自动赋予。实验时必须首先启动主进程服务器。ServerSocket类代表TCP协议对象，包含TCP端口的属性，主要方法accept()接受客户创建Socket会话对象；Socket类代表TCP会话对象，主要方法getInputstream()和getOutputstream()分别用于应用数据流的接收和发送，close()方法关闭会话。 MainServer类，负责接收会话请求并创建服务线程 创建Socket，使用Java提供的ServerSocket，提供端口号 1ServerSocket server = new ServerSocket(5588); 等待会话请求，一旦成功便创建会话对象 1Socket client = server.accept(); 创建ServieServer服务线程，传递会话对象并启动线程 123ServiceServer service = new ServiceServer(client);Thread thread=new Thread(service);thread.start(); ServiceServer类，需要实现Runnable线程接口 从会话对象获取数据流，发送是输出流，接收是输入流 12345public ServiceServer(Socket c)throws IOException{ this.client=c; is=new ObjectInputStream(client.getInputStream()); os=new ObjectOutputStream(client.getOutputStream()); } 利用输入输出流进行数据交换 12345678910try{ Object obj=is.readObject(); if (obj instanceof User){ user=(User)obj; System.out.println(&quot;--User:&quot;+user.getUserID()); os.writeObject(obj); } BufferedReader in = new BufferedReader(new InputStreamReader(client .getInputStream())); out = new PrintWriter(client.getOutputStream()); 关闭会话对象 123in.close();out.close();client.close(); TCPClient类，作为客户端程序 请求同服务端建立会话，指定服务器地址和端口 1serviceSocket = new Socket(this.txtFieldIP.getText(), 5588); 从会话对象获得数据流 123out = new PrintWriter(serviceSocket.getOutputStream()); in = new BufferedReader(new InputStreamReader(serviceSocket .getInputStream())); 关闭会话对象 1serviceSocket.close(); 测试控制程序，创建两个客户程序检验并发服务 12345678910public static void main(String[] args) { TcpClient client1 = new TcpClient(&quot;Jin&quot;); client1.pack(); client1.setSize(400, 360); client1.setVisible(true); TcpClient client2 = new TcpClient(&quot;zhang&quot;); client2.pack(); client2.setSize(400, 360); client2.setVisible(true); } 实验环境实验地点：​ 济事楼330机房 实验设备：​ PC一台，IntelliJ IDEA IDE 实验内容 实现客户端和服务端编程，客户端为TCPClient类，服务端为MainServer和ServiceServer两个类 进行实时通信测试交互。先运行MainServer类，再运行TCPClient类，此时将连续创建两个客户端进程同时访问服务器。在客户端界面中输入要发送的字符串信息，在服务端观察接收，实现即时通信。 实验步骤运行IntelliJ IDEA，创建Socket项目。 在main/src/java下创建软件包edu.tongji.sc.network.socket 在软件包中创建Java类User,这是一个数据类代表用户对象，是辅助类 输入User类代码，用服务器下文件完全覆盖并保存编译。 重复步骤2和3，分别创建TCPClient、ServiceServer、MainServer三个类。 运行测试实验。 运行MainServer，点击右上角运行按钮 运行TcpClient，点击右上角运行按钮，出现两个窗口；分别点击连接，MainServer控制台输出连接消息 在两个客户端接收区分别输入hello和world，MainServer控制台显示处理请求过程，实验成功 实验结论 与无连接通信方式相比，TCP提供了更多的保障，包括错误检测、流量控制等功能，因此TCP适用于那些对数据完整性和可靠性要求较高的场景，更加可靠而有序。 通过在服务端采用多线程的并发模型，为每个客户端连接创建一个独立的线程便可以实现并发服务。这样，每个客户端都能够在独立的线程中执行，互不干扰。 TCP程序采用了并发处理的架构，包括主进程（MainServer）和服务处理线程（ServiceServer）。主进程负责接收客户端请求并创建服务线程，而服务线程则负责具体的会话处理。","link":"/2023/10/25/TCPLab/"},{"title":"UDPLab","text":"UDP协议网络编程实验实验时间：2023.10.8实验目的本实验旨在利用Socket编写一个基于UDP协议的程序，实现即时通信。具体目标如下： 学习Server/Client模型，以及端口在网络通信中的重要作用； 掌握利用Socket编写基于UDP协议的程序的方法。 学习无连接通信方式，理解与面向连接的通信方式的区别。 实验原理UDP即时通信流程图如下： 在流程图中，UDPClient类实现了客户机，UDPServer类实现了服务器。客户机通过端口号5555访问服务器，而客户机端口由系统自动赋予。实验时必须首先启动服务器。DatagramSocket类代表UDP数据对象，DatagramPacket类代表UDP协议对象，包含了代表UDP端口的两个属性。采用无连接服务，直接和对方进行通信，主要方法包括send(DatagramPacket)和receive(DatagramPacket). UDPServer类 创建Socket，创建时需提供端口号 DatagramSocket server=new DatagramSocket(5555); 创建UDP数据包缓存区,存放应用数据 12private byte[] buffer=new byte[101]; private DatagramPacket request; 利用Socket收发数据 12server.receive(request);server.send(request); UDPClient类 获取UDP服务器地址对象并且进行地址解析，从点分十进制IP地址或者域名获取服务器IP地址对象 1234567891011private InetAddress server;private void btnConnectActionPerformed(ActionEvent e) { String serverIP = &quot;&quot;; try { serverIP = this.textFieldIP.getText(); server = InetAddress.getByName(serverIP); ... } catch (UnknownHostException ue) { ... } } 创建Socket对象，不需要提供端口号 DatagramSocket client=new DatagramSocket(); 创建UDP数据包缓存区,存放应用数据,需要指定服务器地址和端口号 1234567891011private DatagramPacket request, response;private byte[] bufferSended; private void btnSendActionPerformed(ActionEvent e) { try { bufferSended = this.textMessage.getText().getBytes(); client = new DatagramSocket();// client request = new DatagramPacket(bufferSended, bufferSended.length, server, 5555); ... } ... } 利用Socket收发数据 12345// send发送数据client.send(request); this.textMessage.setText(&quot;&quot;);// receiveclient.receive(response); 实验环境实验地点：​ 济事楼330机房 实验设备：​ PC一台，IntelliJ IDEA IDE 实验内容 实现客户端和服务端编程，即UDPClient类和UDPServer两个类 进行实时通信测试交互。先运行UDPServer类，再运行UDPClient类，然后在客户端界面中输入要发送的字符串信息，在服务端观察接收，实现即时通信。 实验步骤运行IntelliJ IDEA，创建Socket项目。 在main/src/java下创建软件包edu.tongji.networklab.udp 在软件包中创建Java类UdpClient 输入UdpClient类代码，用服务器下文件完全覆盖并保存编译。 重复2和3步骤，创建Java类UdpServer 运行代码，进行UDP协议下的即时通信 运行UdpServer类（必须先于UdpClient类运行）点击右上角运行按钮 运行UdpClient类，点击右上角运行按钮，弹出客户端Swing界面 点击连接，在文本框输入HelloWorld并点击发送，客户端接收区显示发送文本 UdpServer控制台显示收到客户端请求数据“Hello World”，实验成功！ 实验结论 与TCP面向连接通信不同，UDP不需要在通信前建立连接，显得更加轻量、灵活，适用于那些对实时性要求较高，可以容忍一定数据丢失的场景。 UDP编程更加简洁明了，send()方法用于发送，receive()方法用于接收。 Socket接口类中已经实现了UDP协议相关的一些对象，它提供了创建、传输数据和管理端口的功能，使得程序能够在网络上进行有效的数据交换。","link":"/2023/10/25/UDPLab/"},{"title":"dataExamineLab","text":"异步串联通信收发&amp;奇偶数据校验实验实验时间：2023.10.20实验目的 实验目的旨在通过使用计算机的串行口，展示两台计算机之间字符的传输，深入解释通信的基本原理，并强调了物理层的作用。 链路层的数据校验是一种检测数据是否正确的方法，它可以提高数据通信的可靠性和质量。数据校验在链路层有重要的作用。奇偶校验是一种使用异步串行传输的数据校验方式，它可以通过改变奇偶校验参数来演示数据校验的效果。实验具体目的包括: 理解异步串行通信原理 对RS-232通信标准和帧格式的熟悉 学习通信参数如波特率的作用和使用 学习和掌握奇偶校验的原理和方法 了解数据校验在数据通信中的意义和作用，加深对链路层功能的理解 实验原理 串行传输模式 串行传输模式是一种通信方式，其中每个通信用户独占一个通信信道，按顺序逐位地发送二进制数据，每次传输一个二进制位（0或1）。这种通信方式广泛用于远程通信。 在实际应用中，串行传输模式分为同步串行传输模式和异步串行传输模式。同步串行传输模式要求通信的发送方和接收方在时间基准上保持一致。而异步串行传输模式允许通信的两端使用不同的时间模式，传输前无需协调，只需直接发送数据，而不需要等待对方的响应。在两个数据包之间插入间隔符号以作为分隔。 RS-232接口 RS-232传输对象是字符,每次传输一个字符，同时支持连续传输多个字符。在RS-232的异步串行传输模式中，电压被用作物理信号来传递数据，电压的状态通常在+15V到-15V之间变化。其信号状态标准如下： 空闲状态的信号使用负电压来表示。 数位0则以正电压来表示。 数位1则以负电压来表示. ![image-20231020212623558](/Users/apple/Library/Application Support/typora-user-images/image-20231020212623558.png) 差错控制技术：奇偶数据校验是一种检测数据传输中是否出现错误的方法。它根据数据中的数位1的个数是奇数还是偶数来确定是否有错误。 校验位和码字：奇偶校验在数据的末尾添加一个数位，叫做校验位。校验位的值取决于数据中的数位1的个数的奇偶性,数据和校验位组成了一个新的数据–码字.奇偶校验保证了码字中的数位1的个数总是一样的奇数或者偶数。 奇校验和偶校验：奇偶校验有两种类型，一种是奇校验，一种是偶校验。奇校验要求码字中的数位1的个数是奇数，偶校验要求码字中的数位1的个数是偶数。奇偶校验通常用于传输单个字符，也就是八位二进制数。在数据通信时，发送端要把码字发送出去，接收端要对码字进行计算。如果码字中的数位1的个数符合预期的奇偶性，那么就说明没有错误；如果不符合，那么就说明有错误。 实验环境实验地点：​ 济事楼330机房 实验设备：​ 两台带串口的PC,一根串行交叉线,串口调试软件 ​ 实验拓扑结构如下: 实验内容进行两台计算机之间的串行通信，且控制奇偶校验参数,两主机间发送字符串,具体分为两步: 使用不同校验方式通信。观察一方使用奇校验，另一方不使用校验的通信结果。 使用相同校验方式通信。双方使用偶校验的通信,观察结果。 实验步骤 将两台计算机的COM口用串口反接接线连起来. 运行串口调试软件 使用不同校验位进行通信 Host2使用偶校验,建立异步串行传输连接.通信参数设置为:波特率(9600)、偶校验、数据位(8)、停止位(1) Host1不使用校验位,建立异步串行传输连接.通信参数设置为:波特率(9600)、无校验位、数据位(8)、停止位(1) 点击建立连接，可以看到绿色状态显示。 Host1收发字符。在发送区域输入 “13579”，连续点击 “发送” 按钮发送多组字符。 Host2收发字符。在发送区域输入 “02468”，连续点击 “发送” 按钮发送多组字符。 观察两台主机的接收区域显示 Host1接收到了由Host2发送的多串字符串 “02468”，接收端采用无校验位，这不会影响接收带有校验位的数据。 Host2则接收到了乱码。这是因为接收端采用了偶校验位，它会对接收到的数据进行校验。 使用相同校验位进行通信 修改Host1的通信参数为偶校验,其余参数不变. 两台主机发送操作步骤如上. 观察两台主机的接收区域显示 两台主机都正确收到了数据.校验方式必须接发方保持一致,才能确保数据传递的正确性. 实验结论 异步串行通信工作原理，即通过逐位传输二进制数据，不需要时间基准的协调，可以实现数据的传输。 字符的传输方式以及电压状态的表示，包括空闲状态、数位0和数位1的电压表示,是串行通信中常见的标准之一。 奇偶校验在串行通信中扮演着重要的角色，可以帮助检测数据传输中的错误。 奇校验要求码字中的数位1的个数是奇数，偶校验要求码字中的数位1的个数是偶数。 在实际应用中，通信双方必须保持一致的校验方式，以确保可靠的数据传输。","link":"/2023/10/25/dataExamineLab/"},{"title":"imageGenerator","text":"歌词-台词图像生成应用一、项目简介​ 在当前的数字化时代，随着互联网技术、人工智能模型的不断发展，个性化体验和创意分享已经成为网络文化不可或缺的组成部分。AIGC成为炙手可热的话题,为人们的网络使用体验注入新活力.人们不再满足于被动接受信息，而是更加注重个性化的表达和创意的分享。本应用致力于创建一个简单易用的平台，让用户能够轻松搜索音乐歌词和影视中的台词，并且从中挑选出自己喜欢的歌词或台词进行图像生成。 ​ 通过本应用，用户可以轻松分享自己的感受，通过可视化的方式表达自己关于某些文字的情感和态度。本应用在满足用户对个性化创意追求的同时，也为用户提供了一个丰富多彩的网络文化体验,感受AIGC带来的新奇体验。 二、配置和部署说明2.1配置情况1234567891011Node.js:v18.15.0&quot;dependencies&quot;: { &quot;@element-plus/icons-vue&quot;: &quot;^2.1.0&quot;, &quot;axios&quot;: &quot;^1.5.1&quot;, &quot;core-js&quot;: &quot;^3.8.3&quot;, &quot;element-plus&quot;: &quot;^2.3.14&quot;, &quot;openai&quot;: &quot;^4.12.1&quot;, &quot;vue&quot;: &quot;^3.2.13&quot;, &quot;vue-router&quot;: &quot;^4.2.5&quot;, &quot;vuex&quot;: &quot;^4.1.0&quot;}, 2.2部署说明本项目使用Ngnix部署到服务器47.96.30.31上,浏览器输入http://47.96.30.31/即可访问. 服务器为阿里云平台云服务器ECS,基本配置为: 三、应用功能1.歌曲/电影台词搜索用户可以通过关键词搜索他们喜欢的歌曲、歌手或影视，以便在平台上进行后续操作。在菜单栏进行目标切换. 2.文字选择用户可以从详情页面中选择自己喜欢的歌词或台词，进而进行图像生成。 4.自然语言处理利用ChatGPT接口，将用户选择的歌词/台词转换成适合创作的关键词提供给作画api。 5.多接口整合整合音乐API，以获取歌曲、歌词等信息，整合影视API，以获取影视经典台词，同时调用、chatGPT、stable Diffusion等api，实现图像生成。 四、应用实现1.前端结构src文件夹下路径结构: 123456789101112131415161718.├── App.vue├── assets│ └── logo.png├── components│ ├── firstPageTwo.vue│ ├── fourthPage.vue│ ├── fourthPageLines.vue│ ├── myNavTwo.vue│ ├── secondPage.vue│ ├── secondPageLines.vue│ ├── thirdPage.vue│ └── thirdPageLines.vue├── main.js├── router│ └── index.js└── store └── index.js 其中: App.vue文件是整个应用的布局,使用el-container容器,包裹el-header(导航栏)、el-main(页面主体内容)、el-footer(页面底部),其中el-main中为router-view,根据路由展示不同组件. components目录包括了应用的各个组件,包括:导航栏内容、首页内容、搜索页面结果(音乐/媒体)、详情页面(音乐/媒体)、绘图展示页面(音乐/媒体). 图片等资源文件存放在与src文件夹同级的public目录下. router目录下存放路由配置,store目录下存放容器,保存用户选择状态–音乐或者影视. 2.api调用(1)搜索结果​ 在组件实例创建之前调用onMounted函数,使用首页传递来的queryString向音乐/影视网站发出GET请求,获取所需信息:音乐方面包括歌曲名、艺人名、照片、ID;影视方面包括名字、类型、图片、年份、ID等信息,存入数组中并展示. 以音乐的js代码为例: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;script setup&gt;import { useRouter } from 'vue-router'import { onMounted,ref} from 'vue';const router = useRouter();const queryString=ref('')const topThreeSongsArray=ref([])const topThreeSingerArray=ref([])const topThreeImageArray=ref([])const topThreeIdArray=ref([])//跳转到歌词页面const getLyrics = (index) =&gt; { router.push({ path: '/thirdPage', query: { queryString: topThreeIdArray.value[index-1] }});};//获取搜索结果const getResults=async()=&gt;{ console.log(queryString) const axios = require('axios'); const options = { method: 'GET', url: 'https://genius-song-lyrics1.p.rapidapi.com/search/', params: { q: queryString.value, per_page: '10', page: '1' }, headers: { 'X-RapidAPI-Key': 'e5b6cf43b5msh082c9a6af43d8c7p10b48cjsn744f05e11812', 'X-RapidAPI-Host': 'genius-song-lyrics1.p.rapidapi.com' } }; try { const response = await axios.request(options); console.log(response.data); const topThreeSongs2 = response.data.hits.slice(0,9).map(item =&gt; { return { title: item.result.title, artist: item.result.primary_artist.name, albumImage: item.result.song_art_image_url, id:item.result.id }; }); for(let i=0;i&lt;topThreeSongs2.length;i++){ topThreeSongsArray.value.push(topThreeSongs2[i].title) topThreeSingerArray.value.push(topThreeSongs2[i].artist) topThreeImageArray.value.push(topThreeSongs2[i].albumImage) topThreeIdArray.value.push(topThreeSongs2[i].id) } } catch (error) { console.error(error); }}onMounted(() =&gt; { // 从路由的 query 参数中获取 queryString.value = router.currentRoute.value.query.queryString; getResults();});&lt;/script&gt; (2)详情展示​ 用户在结果页点击获取详情,跳转至详情页;在组件实例创建之前调用onMounted函数,使用搜索结果页传递来的ID获取详细信息:音乐方面包括歌名、歌手图片、歌手名称、专辑图片、专辑名称、发行日期,以及获取全部歌词;影视方面包括名称、类型、图片、日期、种类、大体情节,以及经典台词. 以音乐的js为例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;script setup&gt;import { useRouter } from 'vue-router'import { onMounted,ref} from 'vue';import { Upload } from '@element-plus/icons-vue'import { ElMessage,ElLoading } from 'element-plus'import OpenAI from &quot;openai&quot;const router = useRouter();const selectedLyrics=ref('')const queryString=ref('')const songTitle=ref('')const artistName = ref('')const albumTitle =ref('')const releaseDate = ref('')const albumImage =ref('')const singerImage =ref('')const fullLyrics=ref()//获取歌曲详情const getSongDetail=async()=&gt;{ const axios = require('axios'); const options = { method: 'GET', url: 'https://genius-song-lyrics1.p.rapidapi.com/song/details/', params: {id: queryString.value}, headers: { 'X-RapidAPI-Key': 'e5b6cf43b5msh082c9a6af43d8c7p10b48cjsn744f05e11812', 'X-RapidAPI-Host': 'genius-song-lyrics1.p.rapidapi.com' } }; try { const response = await axios.request(options); songTitle.value=response.data.song.title; albumTitle.value=response.data.song.album.name; artistName.value=response.data.song.primary_artist.name; releaseDate.value=response.data.song.release_date_for_display; albumImage.value=response.data.song.album.cover_art_url; singerImage.value=response.data.song.primary_artist.image_url; console.log(response.data); } catch (error) { console.error(error); }}//获取歌词const getSongLyrics=async()=&gt;{ const axios = require('axios'); const options = { method: 'GET', url: 'https://genius-song-lyrics1.p.rapidapi.com/song/lyrics/', params: {id: queryString.value}, headers: { 'X-RapidAPI-Key': 'e5b6cf43b5msh082c9a6af43d8c7p10b48cjsn744f05e11812', 'X-RapidAPI-Host': 'genius-song-lyrics1.p.rapidapi.com' } }; try { const response = await axios.request(options); console.log(response.data); fullLyrics.value=response.data.lyrics.lyrics.body.html } catch (error) { console.error(error); }}onMounted(() =&gt; { // 从路由的 query 参数中获取 queryString.value = router.currentRoute.value.query.queryString; getSongDetail(); getSongLyrics();});&lt;/script&gt; (3)生成图片​ 点击generate按钮后,首先将文本框内的内容作为content,使用OpenAI接口,让其返回10个prompts;接着,使用这10个prompts调用stable Diffusion的api,让其生成图片,得到最终图片的url,并传递给最后的页面. 以音乐的js为例: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126const generateImage=async()=&gt;{ ElMessage({ message: 'Please be patient,your image is being painted...', type: 'success', }) const axios = require('axios'); //获取prompts const openai = new OpenAI({ apiKey: &quot;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&quot;, dangerouslyAllowBrowser:true}); selectedLyrics.value = &quot;I will give you some sentences, and you just give me 10 key words for all sentences in total.Don't give me anything else,just 10 key words.&quot; + selectedLyrics.value; const response = await openai.chat.completions.create({ model: &quot;gpt-3.5-turbo&quot;, messages: [ { &quot;role&quot;: &quot;user&quot;, &quot;content&quot;: selectedLyrics.value } ], temperature: 1, max_tokens: 256, top_p: 1, frequency_penalty: 0, presence_penalty: 0, }); try { console.log(response.choices[0].message.content); resultPrompts.value=response.choices[0].message.content } catch (error) { console.error(error); } let resultpromptsValue = resultPrompts.value || ''; resultpromptsValue+='11.masterpiece' resultPrompts.value=resultpromptsValue console.log(resultPrompts.value) printedResultPrompts.value=resultPrompts.value.replace('11.masterpiece', ''); console.log(printedResultPrompts.value) //获取生成图片任务的uidconst requestInfo = { method: &quot;POST&quot;, url: &quot;https://23329.o.apispace.com/aigc/txt2img&quot;, headers: { &quot;X-APISpace-Token&quot;: &quot;8qdtf7fect98p1dzkkath5hw5ju5ow1e&quot;, &quot;Authorization-Type&quot;: &quot;apikey&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, }, data: { task: &quot;txt2img.sd&quot;, params: { model: &quot;anime&quot;, text:resultPrompts.value, w: 750, h: 512, guidance_scale: 14, negative_prompt: &quot;cropped, blurred, mutated, error, lowres, blurry, low quality, username, signature, watermark, text, nsfw, missing limb, fused hand, missing hand, extra limbs, malformed limbs, bad hands, extra fingers, fused fingers, missing fingers, bad breasts, deformed, mutilated, morbid, bad anatomy&quot;, sampler: &quot;k_euler&quot;, seed: 1072366942, num_steps: 25, }, model: &quot;anime&quot;, text: resultPrompts.value, w: 750, h: 512, guidance_scale: 14, negative_prompt: &quot;cropped, blurred, mutated, error, lowres, blurry, low quality, username, signature, watermark, text, nsfw, missing limb, fused hand, missing hand, extra limbs, malformed limbs, bad hands, extra fingers, fused fingers, missing fingers, bad breasts, deformed, mutilated, morbid, bad anatomy&quot;, sampler: &quot;k_euler&quot;, seed: 1072366942, num_steps: 25, notify_url: &quot;&quot;, }, } try { const response2 = await axios.request(requestInfo); console.log(response2) console.log(response2.data.data.uid); const resultuid=response2.data.data.uid resultUid.value=resultuid } catch (error) { console.error(error); }//加载组件 const loading = ElLoading.service({ lock: true, text: 'Painting', background: 'rgba(255, 255, 255, 0.5)', }) setTimeout(() =&gt; { loading.close() }, 10000) //延迟10秒获取url setTimeout(async()=&gt;{ const requestInfo2 = { method: &quot;POST&quot;, url: &quot;https://23329.o.apispace.com/aigc/query-image&quot;, headers: { &quot;X-APISpace-Token&quot;: &quot;8qdtf7fect98p1dzkkath5hw5ju5ow1e&quot;, &quot;Authorization-Type&quot;: &quot;apikey&quot;, &quot;Content-Type&quot;: &quot;application/json&quot;, }, data: { uid: resultUid.value, }, }; try { const response3 = await axios.request(requestInfo2); console.log(response3) console.log(response3.data.data.cdn); const resulturl=response3.data.data.cdn resultUrl.value=resulturl } catch (error) { console.error(error); } finalQueryString.value=resultUrl.value+'+'+printedResultPrompts.value router.push({ path: '/fourthPage', query: { finalQueryString: finalQueryString.value }}) },10000)} 五、Web API文档Apifox接口文档(已整合): https://apifox.com/apidoc/shared-a527c342-822e-4ab2-8ecd-05c76645b34a/api-119010480","link":"/2023/10/25/imageGenerator/"}],"tags":[{"name":"study","slug":"study","link":"/tags/study/"}],"categories":[{"name":"MicroService","slug":"MicroService","link":"/categories/MicroService/"},{"name":"ComputerNetworkLab","slug":"ComputerNetworkLab","link":"/categories/ComputerNetworkLab/"}],"pages":[{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"about","text":"","link":"/about/index.html"}]}